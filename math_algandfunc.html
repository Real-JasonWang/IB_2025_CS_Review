<!DOCTYPE html>
<html lang="zh-CN">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>IB Math AA HL 备考测验 - By Jason Wang</title>
      <script src="https://cdn.tailwindcss.com"></script>
      <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
      <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
      <style>
         body {
         font-family: 'Inter', sans-serif;
         overscroll-behavior-y: none; 
         animation: fadeInScaleUp 0.7s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; 
         }
         .option-btn:not([disabled]):hover {
         transform: translateY(-2px); 
         box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); 
         }
         .option-btn:not([disabled]):active {
         transform: translateY(0); 
         box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); 
         }
         .results-enter {
         opacity: 0;
         transform: translateY(30px);
         transition: opacity 0.6s ease-out, transform 0.6s ease-out; 
         }
         .results-enter-active {
         opacity: 1;
         transform: translateY(0);
         }
         .option-btn:disabled {
         cursor: not-allowed; 
         opacity: 0.7; 
         }
         .correct-answer {
         background-color: #22c55e !important; 
         color: white !important;
         border-color: #16a34a !important;
         }
         .wrong-answer {
         background-color: #ef4444 !important; 
         color: white !important;
         border-color: #dc2626 !important;
         }
         .progress-bar-container {
         background-color: #e5e7eb; 
         border-radius: 9999px; 
         overflow: hidden; 
         height: 1rem; 
         margin-bottom: 1.5rem; 
         }
         .progress-bar {
         background-color: #4f46e5; 
         height: 100%;
         transition: width 0.3s ease-in-out; 
         text-align: center;
         color: white;
         font-size: 0.75rem; 
         line-height: 1rem; 
         font-weight: 500;
         border-radius: 9999px;
         }
         #confetti-canvas {
         position: fixed; 
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         pointer-events: none; 
         z-index: 9999; 
         }
         .explanation {
         background-color: #f3f4f6; 
         border-left: 4px solid #4f46e5; 
         padding: 1rem; 
         border-radius: 0.375rem; 
         color: #374151; 
         font-size: 0.875rem; 
         margin-top: 1rem; 
         line-height: 1.5; 
         }
         .option-btn, #next-btn, #restart-btn {
         -webkit-tap-highlight-color: transparent; 
         }
         @keyframes fadeInScaleUp { 
         from { opacity: 0; transform: scale(0.92); }
         to { opacity: 1; transform: scale(1); }
         }
      </style>
   </head>
   <body class="bg-gradient-to-br from-sky-100 via-indigo-100 to-purple-100 min-h-screen flex flex-col items-center justify-center p-4 relative">
      <canvas id="confetti-canvas"></canvas>
      <div id="quiz-container" class="bg-white rounded-xl shadow-2xl p-6 md:p-10 w-full max-w-4xl relative z-10">
         <a href="index.html"
            class="inline-block text-center justify-center items-center bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-opacity-50 mb-4">
         👈 主页
         </a>
         <h1 class="text-3xl font-bold text-center text-gray-800 mb-2 mt-2">IB Math AA HL备考测验</h1>
         <p class="text-center text-gray-600 mb-6">测试你对代数与函数的了解程度！</p>
         <div id="game-area">
            <div class="flex justify-between items-center mb-4 text-gray-600">
               <span id="question-counter" class="text-sm md:text-base font-medium">问题 1 / 10</span>
               <span id="score-display" class="text-sm md:text-base font-medium">得分: 0 / 0 (0%)</span>
            </div>
            <div class="progress-bar-container">
               <div id="progress-bar" class="progress-bar" style="width: 0%;">0%</div>
            </div>
            <div id="question-container" class="mb-6">
               <h2 id="question-text" class="text-lg md:text-xl font-semibold text-gray-700 leading-relaxed min-h-[4.5em] md:min-h-[3em]">问题文本加载中...</h2>
            </div>
            <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-3 md:gap-4 mb-6">
            </div>
            <div id="feedback-area" class="text-center h-auto mb-4 text-base font-medium hidden">
               <div id="feedback-text" class="text-lg font-semibold mb-2"></div>
               <div id="explanation-text" class="explanation text-left"></div>
            </div>
            <div class="text-center">
               <button id="next-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2.5 px-6 rounded-lg shadow-md transition duration-300 ease-in-out hidden">
               下一题
               </button>
            </div>
         </div>
         <div id="results-area" class="hidden text-center">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">🎉 测验完成! 🎉</h2>
            <p id="final-score" class="text-xl text-gray-700 mb-6"></p>
            <p id="result-message" class="text-lg text-gray-600 mb-8"></p>
            <button id="restart-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md transition duration-300 ease-in-out">
            重新开始
            </button>
         </div>
         <p class="text-center text-xs text-gray-500 mb-1 mt-6">&copy; 2024-2025 IB Revision Toys. Design & Made with Love by Jason Wang.</p>
      </div>
      <script>
         const questions = [
         {
         question: "等差数列的定义是什么？",
         options: [
         "后一项与前一项的比值是常数",
         "后一项与前一项的差值是常数",
         "每一项都等于前一项的平方",
         "数列中所有项的和是一个定值"
         ],
         answer: "后一项与前一项的差值是常数",
         explanation: "等差数列的定义是任意相邻两项的差（后项减前项）等于同一个常数，这个常数称为公差 (d)。"
         },
         {
         question: "等差数列 {u_n} 的通项公式是什么？（u_1 为首项，d 为公差）",
         options: [
         "u_n = u_1 * d^(n-1)",
         "u_n = u_1 + n*d",
         "u_n = u_1 + (n-1)*d",
         "u_n = n/2 * (u_1 + u_n)"
         ],
         answer: "u_n = u_1 + (n-1)*d",
         explanation: "等差数列的第 n 项等于首项加上 (n-1) 倍的公差。"
         },
         {
         question: "等差数列前 n 项和 S_n 的公式之一是什么？",
         options: [
         "S_n = n * u_1 + d",
         "S_n = n/2 * (u_1 + (n-1)*d)",
         "S_n = u_1 * (1 - d^n) / (1 - d)",
         "S_n = n/2 * (2*u_1 + (n-1)*d)"
         ],
         answer: "S_n = n/2 * (2*u_1 + (n-1)*d)",
         explanation: "等差数列前 n 项和的公式可以是 S_n = n/2 * (u_1 + u_n) 或 S_n = n/2 * (2*u_1 + (n-1)*d)。"
         },
         {
         question: "等比数列的定义是什么？",
         options: [
         "后一项与前一项的差值是常数",
         "后一项与前一项的比值是常数 (且不为0)",
         "每一项都等于前一项加上一个常数",
         "数列中所有项的乘积是一个定值"
         ],
         answer: "后一项与前一项的比值是常数 (且不为0)",
         explanation: "等比数列的定义是任意相邻两项的比（后项除以前项）等于同一个常数（公比 r），且公比和各项均不为零。"
         },
         {
         question: "等比数列 {u_n} 的通项公式是什么？（u_1 为首项，r 为公比）",
         options: [
         "u_n = u_1 + (n-1)*r",
         "u_n = u_1 * r^(n-1)",
         "u_n = u_1 * r^n",
         "u_n = u_1 + r^(n-1)"
         ],
         answer: "u_n = u_1 * r^(n-1)",
         explanation: "等比数列的第 n 项等于首项乘以公比的 (n-1) 次方。"
         },
         {
         question: "等比数列前 n 项和 S_n 的公式是什么？(r ≠ 1)",
         options: [
         "S_n = n/2 * (u_1 + u_n)",
         "S_n = u_1 * (1 - r^n) / (1 - r)",
         "S_n = u_1 * (r^n + 1) / (r + 1)",
         "S_n = n * u_1 * r"
         ],
         answer: "S_n = u_1 * (1 - r^n) / (1 - r)",
         explanation: "当公比 r 不等于 1 时，等比数列前 n 项和的公式是 S_n = u_1 * (1 - r^n) / (1 - r) 或 S_n = u_1 * (r^n - 1) / (r - 1)。"
         },
         {
         question: "求和符号 Σ 的性质 sum(c*f(i)) 等于什么？（c 是常数）",
         options: [
         "c + sum(f(i))",
         "sum(c) * sum(f(i))",
         "c * sum(f(i))",
         "sum(f(c*i))"
         ],
         answer: "c * sum(f(i))",
         explanation: "求和符号的性质之一是常数因子可以提到求和符号的前面。"
         },
         {
         question: "无穷收敛几何级数的求和条件是什么？（r 为公比）",
         options: [
         "r > 1",
         "r = 1",
         "|r| > 1",
         "|r| < 1"
         ],
         answer: "|r| < 1",
         explanation: "无穷几何级数收敛（即其和存在）的充分必要条件是公比 r 的绝对值小于 1。"
         },
         {
         question: "无穷收敛几何级数的和 S_infinity 的公式是什么？（u_1 为首项，r 为公比）",
         options: [
         "S_infinity = u_1 / (1 + r)",
         "S_infinity = u_1 / (1 - r)",
         "S_infinity = u_1 * (1 - r)",
         "S_infinity = r / (1 - u_1)"
         ],
         answer: "S_infinity = u_1 / (1 - r)",
         explanation: "当无穷几何级数收敛 (|r| < 1) 时，其和为首项除以 (1 - 公比)。"
         },
         {
         question: "单利 (Simple Interest) 的计算方式主要是基于哪个量？",
         options: [
         "每次计息周期结束时的本息和",
         "原始本金",
         "最后一年的利息",
         "平均年利率"
         ],
         answer: "原始本金",
         explanation: "单利的特点是利息始终根据原始本金计算，不会将先前产生的利息计入下一期本金。"
         },
         {
         question: "复利 (Compound Interest) 与单利的主要区别在于？",
         options: [
         "复利的利率通常更高",
         "复利只适用于长期投资",
         "复利会将先前产生的利息计入下一期本金（利滚利）",
         "单利计算更复杂"
         ],
         answer: "复利会将先前产生的利息计入下一期本金（利滚利）",
         explanation: "复利的核心在于“利滚利”，即每一计息周期的利息都会加入本金，成为下一周期计算利息的基础。"
         },
         
         {
         question: "指数运算法则 a^m * a^n 等于什么？",
         options: [
         "a^(m*n)",
         "a^(m-n)",
         "a^(m+n)",
         "(a*a)^(m*n)"
         ],
         answer: "a^(m+n)",
         explanation: "同底数幂相乘，底数不变，指数相加。"
         },
         {
         question: "指数运算法则 (a^m)^n 等于什么？",
         options: [
         "a^(m+n)",
         "a^(m*n)",
         "a^(m/n)",
         "n * a^m"
         ],
         answer: "a^(m*n)",
         explanation: "幂的乘方，底数不变，指数相乘。"
         },
         {
         question: "a^0 等于什么？(a ≠ 0)",
         options: [
         "0",
         "1",
         "a",
         "未定义"
         ],
         answer: "1",
         explanation: "任何非零数的 0 次方都等于 1。"
         },
         {
         question: "a^(-n) 等于什么？",
         options: [
         "-a^n",
         "1 / a^n",
         "n * sqrt(a)",
         "a / n"
         ],
         answer: "1 / a^n",
         explanation: "一个数的负指数幂等于它的正指数幂的倒数。"
         },
         {
         question: "对数 log_a(b) = x 的等价指数形式是什么？",
         options: [
         "a^x = b",
         "b^x = a",
         "x^a = b",
         "a^b = x"
         ],
         answer: "a^x = b",
         explanation: "对数是指数运算的逆运算。log_a(b) = x 意味着 a 的 x 次方等于 b。"
         },
         {
         question: "自然对数 ln(x) 的底数是什么？",
         options: [
         "10",
         "2",
         "e (欧拉数)",
         "x"
         ],
         answer: "e (欧拉数)",
         explanation: "自然对数是以欧拉数 e (约等于 2.71828) 为底的对数，即 ln(x) = log_e(x)。"
         },
         {
         question: "对数运算法则 log_a(x*y) 等于什么？",
         options: [
         "log_a(x) * log_a(y)",
         "log_a(x) + log_a(y)",
         "log_a(x) - log_a(y)",
         "log_a(x+y)"
         ],
         answer: "log_a(x) + log_a(y)",
         explanation: "积的对数等于对数的和。"
         },
         {
         question: "对数运算法则 log_a(x^n) 等于什么？",
         options: [
         "(log_a(x))^n",
         "n + log_a(x)",
         "n * log_a(x)",
         "log_a(n*x)"
         ],
         answer: "n * log_a(x)",
         explanation: "幂的对数等于指数乘以底数的对数。"
         },
         {
         question: "对数换底公式 log_a(b) 可以表示成什么？（c 为新底数）",
         options: [
         "log_c(a) / log_c(b)",
         "log_c(b) / log_c(a)",
         "log_b(c) / log_a(c)",
         "log_c(a) * log_c(b)"
         ],
         answer: "log_c(b) / log_c(a)",
         explanation: "换底公式允许将以 a 为底 b 的对数转换为以任意合规底数 c 的对数之比。"
         },
         {
         question: "解指数方程 a^x = a^y (a>0, a≠1) 可以得到什么结论？",
         options: [
         "x = y",
         "x = 1/y",
         "x + y = 0",
         "x * y = 1"
         ],
         answer: "x = y",
         explanation: "如果底数相同且大于0不等于1，指数相等时，幂才相等。"
         },
         {
         question: "对数函数 y = log_a(x) 的定义域是什么？ (a>0, a≠1)",
         options: [
         "所有实数 R",
         "所有非负实数 [0, +∞)",
         "所有正实数 (0, +∞)",
         "所有不等于 1 的实数"
         ],
         answer: "所有正实数 (0, +∞)",
         explanation: "对数的真数（参数 x）必须大于 0。"
         },
         {
         question: "指数函数 y = a^x 的图像恒过哪个点？ (a>0, a≠1)",
         options: [
         "(0, 0)",
         "(1, 0)",
         "(0, 1)",
         "(1, 1)"
         ],
         answer: "(0, 1)",
         explanation: "任何底数（a>0, a≠1）的 0 次方都等于 1，所以图像恒过点 (0, 1)。"
         },
         {
         question: "对数函数 y = log_a(x) 的图像恒过哪个点？ (a>0, a≠1)",
         options: [
         "(0, 0)",
         "(1, 0)",
         "(0, 1)",
         "(a, 0)"
         ],
         answer: "(1, 0)",
         explanation: "当 x=1 时，log_a(1) = 0，所以图像恒过点 (1, 0)。"
         },
         {
         question: "函数 y = a^x 和 y = log_a(x) (a>0, a≠1) 的关系是什么？",
         options: [
         "它们是相同的函数",
         "它们互为反函数",
         "它们的图像关于原点对称",
         "它们的图像关于 y 轴对称"
         ],
         answer: "它们互为反函数",
         explanation: "指数函数和对数函数在底数相同时互为反函数，它们的图像关于直线 y = x 对称。"
         },
         
         {
         question: "帕斯卡三角形 (Pascal's Triangle) 主要用于确定什么？",
         options: [
         "等差数列的公差",
         "等比数列的公比",
         "二项式展开式的系数",
         "对数函数的值"
         ],
         answer: "二项式展开式的系数",
         explanation: "帕斯卡三角形的第 n+1 行（从第0行开始计数）的数字对应于 (a+b)^n 展开式中的各项系数 C(n, r)。"
         },
         {
         question: "组合数 C(n, r) 或 nCr 代表什么？",
         options: [
         "从 n 个不同元素中取出 r 个元素进行排列的方案数",
         "从 n 个不同元素中取出 r 个元素进行组合的方案数",
         "n 个元素乘以 r",
         "n 的 r 次方"
         ],
         answer: "从 n 个不同元素中取出 r 个元素进行组合的方案数",
         explanation: "组合数 C(n, r) 表示从 n 个不同的元素中无序地选取 r 个元素的集合数量。"
         },
         {
         question: "二项式定理 (a+b)^n 展开式中的通项 T_(r+1) 是什么？",
         options: [
         "C(n, r) * a^r * b^(n-r)",
         "C(n, r) * a^(n-r) * b^r",
         "C(n, n-r) * a^n * b^r",
         "P(n, r) * a^(n-r) * b^r"
         ],
         answer: "C(n, r) * a^(n-r) * b^r",
         explanation: "二项式 (a+b)^n 展开式的第 r+1 项（其中 r 从 0 开始计数）是 T_(r+1) = C(n, r) * a^(n-r) * b^r。"
         },
         {
         question: "(a+b)^3 展开的结果是什么？",
         options: [
         "a^3 + b^3",
         "a^3 + a^2b + ab^2 + b^3",
         "a^3 + 3a^2b + 3ab^2 + b^3",
         "3a^3 + 3b^3"
         ],
         answer: "a^3 + 3a^2b + 3ab^2 + b^3",
         explanation: "根据二项式定理或帕斯卡三角形，(a+b)^3 = C(3,0)a^3b^0 + C(3,1)a^2b^1 + C(3,2)a^1b^2 + C(3,3)a^0b^3 = 1*a^3 + 3*a^2b + 3*ab^2 + 1*b^3。"
         },
         {
         question: "(HL) 对于有理数指数 n 的二项式展开 (1+x)^n = 1 + nx + ...，其收敛的条件是什么？",
         options: [
         "x > 1",
         "x < -1",
         "|x| = 1",
         "|x| < 1"
         ],
         answer: "|x| < 1",
         explanation: "当指数 n 不是正整数时，二项式级数展开式收敛（即有效）的条件是 |x| < 1。"
         },
         
         {
         question: "假设完成一件事需要按顺序分两个步骤，第一步有 3 种方法，第二步有 4 种方法。完成这件事总共有多少种方法？",
         options: [
         "3 + 4 = 7",
         "4 - 3 = 1",
         "3 * 4 = 12",
         "4 / 3"
         ],
         answer: "3 * 4 = 12",
         explanation: "这应用了乘法原理：如果一个任务可以分解为连续的步骤，总方法数是每一步方法数的乘积。"
         },
         {
         question: "假设完成一件事可以通过两种不同的方式完成，第一种方式有 5 种方法，第二种方式有 2 种方法。完成这件事总共有多少种方法？",
         options: [
         "5 * 2 = 10",
         "5 - 2 = 3",
         "5 + 2 = 7",
         "5 / 2"
         ],
         answer: "5 + 2 = 7",
         explanation: "这应用了加法原理：如果一个任务可以通过几种互斥的方式完成，总方法数是每种方式方法数的和。"
         },
         {
         question: "排列 (Permutation) P(n, r) 和组合 (Combination) C(n, r) 的主要区别是什么？",
         options: [
         "排列考虑顺序，组合不考虑顺序",
         "组合考虑顺序，排列不考虑顺序",
         "排列允许重复，组合不允许重复",
         "它们计算的是相同的东西"
         ],
         answer: "排列考虑顺序，组合不考虑顺序",
         explanation: "排列关注的是元素的选取及其排列顺序，而组合只关注元素的选取，不关心它们的顺序。"
         },
         {
         question: "从 5 本不同的书中选出 3 本进行排列，放在书架上，有多少种不同的排法？应该使用哪个公式？",
         options: [
         "C(5, 3)",
         "P(5, 3)",
         "5^3",
         "3^5"
         ],
         answer: "P(5, 3)",
         explanation: "因为书是不同的，并且放在书架上要考虑顺序，所以这是一个排列问题，应使用 P(n, r) = n! / (n-r)!。"
         },
         {
         question: "从 5 个不同的球中选出 3 个球组成一个集合，有多少种不同的选法？应该使用哪个公式？",
         options: [
         "C(5, 3)",
         "P(5, 3)",
         "5!",
         "3!"
         ],
         answer: "C(5, 3)",
         explanation: "因为只是选出球组成集合，不考虑球的顺序，所以这是一个组合问题，应使用 C(n, r) = n! / (r! * (n-r)!)。"
         },
         
         {
         question: "(HL) 虚数单位 i 的定义是什么？",
         options: [
         "i = 1",
         "i = -1",
         "i^2 = 1",
         "i^2 = -1"
         ],
         answer: "i^2 = -1",
         explanation: "虚数单位 i 定义为其平方等于 -1，即 i = sqrt(-1)。"
         },
         {
         question: "(HL) 复数 z = a + bi 中，a 和 b 分别称为什么？",
         options: [
         "a 是虚部, b 是实部",
         "a 是实部, b 是虚部",
         "a 是模, b 是辐角",
         "a 是辐角, b 是模"
         ],
         answer: "a 是实部, b 是虚部",
         explanation: "在笛卡尔形式 z = a + bi 中，a 称为实部 (Real part, Re(z))，b 称为虚部 (Imaginary part, Im(z))。"
         },
         {
         question: "(HL) 阿甘图 (Argand diagram) 的用途是什么？",
         options: [
         "绘制实数函数图像",
         "在复平面上表示复数",
         "展示数列的收敛性",
         "计算矩阵的行列式"
         ],
         answer: "在复平面上表示复数",
         explanation: "阿甘图使用一个二维平面（复平面）来几何地表示复数，其中横轴代表实部，纵轴代表虚部。"
         },
         {
         question: "(HL) 如果复数 z = a + bi，它的共轭复数 z_conjugate 是什么？",
         options: [
         "-a + bi",
         "a - bi",
         "-a - bi",
         "b + ai"
         ],
         answer: "a - bi",
         explanation: "共轭复数是通过改变原复数虚部的符号得到的。"
         },
         {
         question: "(HL) 复数 z = a + bi 的模 |z| (Modulus) 在几何上代表什么？",
         options: [
         "复数点到虚轴的距离",
         "复数点到实轴的距离",
         "复数点到原点的距离",
         "复数点与其实轴投影的夹角"
         ],
         answer: "复数点到原点的距离",
         explanation: "复数的模 |z| = sqrt(a^2 + b^2)，在阿甘图上表示该复数对应的点到原点 (0,0) 的距离。"
         },
         {
         question: "(HL) 复数 z 的辐角 arg(z) (Argument) 在几何上代表什么？",
         options: [
         "复数点到原点的距离",
         "从正实轴到连接原点与复数点的向量的夹角",
         "复数的实部大小",
         "复数的虚部大小"
         ],
         answer: "从正实轴到连接原点与复数点的向量的夹角",
         explanation: "辐角 arg(z) = θ 是一个角度，表示从正实轴（positive real axis）逆时针旋转到连接原点和复数 z 对应点的射线所成的角度。"
         },
         {
         question: "(HL) 复数的欧拉形式 (Euler Form) 是什么？",
         options: [
         "z = a + bi",
         "z = r(cosθ + i sinθ)",
         "z = r * e^(iθ)",
         "z = |z| * tan(θ)"
         ],
         answer: "z = r * e^(iθ)",
         explanation: "欧拉形式使用模 r 和辐角 θ 将复数表示为 z = r * e^(iθ)，其中 e 是自然对数的底数。"
         },
         {
         question: "(HL) 欧拉公式 (Euler's formula) 联系了哪些重要的数学概念？",
         options: [
         "指数函数、对数函数、常数",
         "指数函数、三角函数、虚数单位",
         "多项式函数、有理函数、根",
         "序列、级数、极限"
         ],
         answer: "指数函数、三角函数、虚数单位",
         explanation: "欧拉公式 e^(iθ) = cos(θ) + i*sin(θ) 建立了一个指数函数 (e^(iθ)) 和三角函数 (cosθ, sinθ) 以及虚数单位 i 之间的桥梁。"
         },
         {
         question: "(HL) 棣莫弗定理 (De Moivre's Theorem) [r(cosθ + i sinθ)]^n 等于什么？",
         options: [
         "r^n (cosθ + i sinθ)",
         "r (cos(nθ) + i sin(nθ))",
         "r^n (cos(nθ) + i sin(nθ))",
         "n*r (cosθ + i sinθ)^n"
         ],
         answer: "r^n (cos(nθ) + i sin(nθ))",
         explanation: "棣莫弗定理说明，复数的 n 次方（n为整数）等于模的 n 次方乘以辐角的 n 倍的余弦和正弦组合。"
         },
         {
         question: "(HL) 两个复数相乘时，它们的模和辐角如何变化？",
         options: [
         "模相乘，辐角相减",
         "模相加，辐角相乘",
         "模相乘，辐角相加",
         "模相除，辐角相加"
         ],
         answer: "模相乘，辐角相加",
         explanation: "几何上，两个复数相乘的效果是：新复数的模等于原来两个复数模的乘积，新复数的辐角等于原来两个复数辐角的和 (模 2π)。"
         },
         {
         question: "(HL) 方程 z^n = w 的 n 个复数根在阿甘图上具有什么几何特性？",
         options: [
         "它们都落在实轴上",
         "它们形成一条直线",
         "它们均匀分布在一个圆心为原点的圆上",
         "它们都相等"
         ],
         answer: "它们均匀分布在一个圆心为原点的圆上",
         explanation: "一个非零复数的 n 个 n 次方根在复平面上构成一个正 n 边形的顶点，这个正 n 边形的中心是原点，顶点都位于同一个圆上。"
         },
         {
         question: "(HL) 数学归纳法主要用于证明哪类命题？",
         options: [
         "关于所有实数的命题",
         "关于所有复数的命题",
         "关于所有正整数（或从某个整数开始的整数）的命题",
         "关于几何图形的命题"
         ],
         answer: "关于所有正整数（或从某个整数开始的整数）的命题",
         explanation: "数学归纳法是一种证明方法，特别适用于证明与自然数（或某个起始整数之后的所有整数）相关的公式、性质或命题。"
         },
         {
         question: "(HL) 数学归纳法证明的第一步“基础步骤 (Base Case)”的目的是什么？",
         options: [
         "假设命题对 k 成立",
         "证明命题对起始值成立",
         "推导命题对 k+1 成立",
         "总结证明结论"
         ],
         answer: "证明命题对起始值成立",
         explanation: "基础步骤是为了确保证明有一个牢固的起点，证明命题对于序列中的第一个值（通常是 n=1 或指定的最小值）是正确的。"
         },
         {
         question: "(HL) 数学归纳法证明的第二步“归纳假设 (Inductive Hypothesis)”是做什么？",
         options: [
         "证明 P(1) 成立",
         "假设 P(k) 对某个整数 k 成立",
         "证明 P(k+1) 成立",
         "找到反例"
         ],
         answer: "假设 P(k) 对某个整数 k 成立",
         explanation: "归纳假设是暂时假定命题对于某个任意但固定的整数 k (k 大于或等于起始值) 是成立的，以便进行下一步的推导。"
         },
         {
         question: "(HL) 数学归纳法证明的第三步“归纳步骤 (Inductive Step)”的目标是什么？",
         options: [
         "证明 P(1) 成立",
         "假设 P(k) 成立",
         "证明如果 P(k) 成立，那么 P(k+1) 也成立",
         "证明 P(k) 不成立"
         ],
         answer: "证明如果 P(k) 成立，那么 P(k+1) 也成立",
         explanation: "归纳步骤是核心的推导环节，需要利用 P(k) 成立的假设，通过逻辑推理证明 P(k+1) 也必定成立，从而建立起多米诺骨牌效应。"
         },
         
         {
         question: "(HL) 对于一个三元线性方程组，其系数矩阵的行列式 det(A) ≠ 0 意味着什么？",
         options: [
         "方程组无解",
         "方程组有无穷多解",
         "方程组有唯一解",
         "无法判断解的情况"
         ],
         answer: "方程组有唯一解",
         explanation: "当线性方程组的系数矩阵的行列式不为零时，该方程组存在唯一的解。"
         },
         {
         question: "(HL) 对于一个三元线性方程组，其系数矩阵的行列式 det(A) = 0 意味着什么？",
         options: [
         "方程组一定无解",
         "方程组一定有无穷多解",
         "方程组有唯一解",
         "方程组可能有无穷多解或无解"
         ],
         answer: "方程组可能有无穷多解或无解",
         explanation: "当系数矩阵的行列式为零时，方程组要么没有解，要么有无穷多解，需要进一步分析增广矩阵。"
         },
         {
         question: "(HL) 在三维空间中，一个有唯一解的三元线性方程组的几何解释是什么？",
         options: [
         "三个平面平行",
         "三个平面相交于一条直线",
         "三个平面相交于一个点",
         "三个平面两两相交但无共同交点"
         ],
         answer: "三个平面相交于一个点",
         explanation: "每个三元线性方程代表三维空间中的一个平面。唯一解对应于这三个平面恰好交于唯一一个公共点的情况。"
         },
         {
         question: "(HL) 在高斯消元法中，以下哪项不是允许的行操作？",
         options: [
         "交换两行",
         "某一行乘以一个非零常数",
         "某一行加上另一行的倍数",
         "将某一行替换为全零行"
         ],
         answer: "将某一行替换为全零行",
         explanation: "高斯消元法的行操作包括交换两行、一行乘以非零常数、一行加上另一行的倍数。随意将一行变为全零行会改变方程组的解集，是不允许的。"
         },
         {
         question: "(HL) 在三维空间中，三个平面两两相交但没有共同交点（形成一个三角柱形空间）对应线性方程组解的哪种情况？",
         options: [
         "唯一解",
         "无穷多解",
         "无解",
         "无法确定"
         ],
         answer: "无解",
         explanation: "这种情况表示没有一个点同时满足所有三个方程，因此方程组无解。"
         },
         {
         question: "(HL) 部分分式分解 (Partial Fractions) 的主要目的是什么？",
         options: [
         "解多项式方程",
         "简化复杂有理函数以便于积分等运算",
         "求函数的极限",
         "绘制函数图像"
         ],
         answer: "简化复杂有理函数以便于积分等运算",
         explanation: "部分分式分解技术可以将一个分母可以因式分解的复杂有理函数拆分成若干个更简单的分式之和，这在积分计算中尤其有用。"
         },
         {
         question: "(HL) 将有理函数 P(x) / ((ax+b)(cx+d)) (其中 ax+b 和 cx+d 是不同的线性因子) 进行部分分式分解，其形式通常是什么？",
         options: [
         "A/(ax+b) + B/(cx+d)",
         "A/(ax+b)^2 + B/(cx+d)",
         "(Ax+B)/((ax+b)(cx+d))",
         "A + B/(ax+b) + C/(cx+d)"
         ],
         answer: "A/(ax+b) + B/(cx+d)",
         explanation: "当分母是不同线性因子的乘积时，部分分式分解的形式是每个线性因子对应一个常数分子项的和。"
         },
         {
         question: "(HL) 将有理函数 P(x) / (ax+b)^2 进行部分分式分解，其形式通常是什么？",
         options: [
         "A/(ax+b)^2",
         "A/(ax+b) + B/(ax+b)^2",
         "(Ax+B)/(ax+b)^2",
         "A/((ax+b)^2)"
         ],
         answer: "A/(ax+b) + B/(ax+b)^2",
         explanation: "当分母包含重复的线性因子 (ax+b)^n 时，分解式中需要包含从 1 次到 n 次幂的每一项，即 A1/(ax+b) + A2/(ax+b)^2 + ... + An/(ax+b)^n。"
         },
         {
         question: "(HL) 当有理函数的分母包含不可约的二次因子 ax^2+bx+c (b^2-4ac < 0) 时，对应的部分分式形式的分子应该是什么？",
         options: [
         "常数 A",
         "线性表达式 Ax+B",
         "二次表达式 Ax^2+Bx+C",
         "零"
         ],
         answer: "线性表达式 Ax+B",
         explanation: "对于分母中不可约的二次因子 ax^2+bx+c，其对应的部分分式的分子应该是一个次数比分母低一次的多项式，即线性表达式 Ax+B。"
         },
         
         {
         question: "函数的严格定义强调了什么？",
         options: [
         "定义域中的每个输入可以映射到多个输出",
         "定义域中的每个输入必须映射到值域中唯一的输出",
         "值域中的每个输出必须对应唯一的输入",
         "函数图像必须是连续的"
         ],
         answer: "定义域中的每个输入必须映射到值域中唯一的输出",
         explanation: "函数的关键在于其映射的唯一性：一个输入 x 只能对应一个输出 f(x)。"
         },
         {
         question: "函数 f(x) = 1 / (x-2) 的定义域是什么？",
         options: [
         "所有实数 R",
         "所有实数，除了 x=0",
         "所有实数，除了 x=2",
         "所有正实数"
         ],
         answer: "所有实数，除了 x=2",
         explanation: "函数的定义域需要排除使表达式无意义的值。在这里，分母不能为零，所以 x-2 ≠ 0，即 x ≠ 2。"
         },
         {
         question: "垂直线测试 (Vertical Line Test) 用于判断什么？",
         options: [
         "一个图像是否代表一个函数",
         "一个函数是否为偶函数",
         "一个函数是否存在反函数",
         "一个函数的增减性"
         ],
         answer: "一个图像是否代表一个函数",
         explanation: "如果任何一条垂直线与图像的交点不超过一个，那么这个图像就代表一个函数关系。"
         },
         {
         question: "复合函数 (f o g)(x) 的计算顺序是什么？",
         options: [
         "先计算 f(x)，再计算 g(x)",
         "先计算 g(x)，再将结果代入 f",
         "同时计算 f(x) 和 g(x)",
         "计算 f(x) * g(x)"
         ],
         answer: "先计算 g(x)，再将结果代入 f",
         explanation: "复合函数 (f o g)(x) 的定义是 f(g(x))，意味着先对 x 应用函数 g，然后将 g(x) 的输出作为函数 f 的输入。"
         },
         {
         question: "一个函数存在反函数 f^(-1) 的条件是什么？",
         options: [
         "函数必须是连续的",
         "函数必须是可微的",
         "函数必须是一一对应的 (bijective)",
         "函数必须经过原点"
         ],
         answer: "函数必须是一一对应的 (bijective)",
         explanation: "只有当函数既是单射（一对一，injective）又是满射（surjective）时，即每个输出值只对应一个输入值，才能确保其反函数也是一个函数。"
         },
         {
         question: "水平线测试 (Horizontal Line Test) 用于判断什么？",
         options: [
         "一个图像是否代表一个函数",
         "一个函数是否为奇函数",
         "一个函数是否是单射（一对一）",
         "一个函数的周期性"
         ],
         answer: "一个函数是否是单射（一对一）",
         explanation: "如果任何一条水平线与函数图像的交点不超过一个，那么这个函数就是单射（一对一），这是存在反函数的一个必要条件。"
         },
         {
         question: "函数 y = f(x) 与其反函数 y = f^(-1)(x) 的图像之间有什么关系？",
         options: [
         "关于原点对称",
         "关于 y 轴对称",
         "关于 x 轴对称",
         "关于直线 y = x 对称"
         ],
         answer: "关于直线 y = x 对称",
         explanation: "如果点 (a, b) 在 y = f(x) 的图像上，那么点 (b, a) 就在 y = f^(-1)(x) 的图像上，这表现为图像关于直线 y = x 对称。"
         },
         {
         question: "如果一个函数满足 f(-x) = f(x) 对于其定义域内的所有 x 都成立，那么这个函数称为什么？",
         options: [
         "奇函数 (Odd Function)",
         "偶函数 (Even Function)",
         "周期函数 (Periodic Function)",
         "反函数 (Inverse Function)"
         ],
         answer: "偶函数 (Even Function)",
         explanation: "偶函数的定义是 f(-x) = f(x)，其图像关于 y 轴对称。"
         },
         {
         question: "如果一个函数满足 f(-x) = -f(x) 对于其定义域内的所有 x 都成立，那么这个函数称为什么？",
         options: [
         "奇函数 (Odd Function)",
         "偶函数 (Even Function)",
         "常数函数 (Constant Function)",
         "线性函数 (Linear Function)"
         ],
         answer: "奇函数 (Odd Function)",
         explanation: "奇函数的定义是 f(-x) = -f(x)，其图像关于原点对称。"
         },
         {
         question: "函数 f(x) = x^3 是什么类型的函数？",
         options: [
         "偶函数",
         "奇函数",
         "既不是奇函数也不是偶函数",
         "既是奇函数也是偶函数"
         ],
         answer: "奇函数",
         explanation: "因为 f(-x) = (-x)^3 = -x^3 = -f(x)，所以 f(x) = x^3 是奇函数。"
         },
         {
         question: "函数 f(x) = cos(x) 是什么类型的函数？",
         options: [
         "偶函数",
         "奇函数",
         "既不是奇函数也不是偶函数",
         "无法判断"
         ],
         answer: "偶函数",
         explanation: "因为 cos(-x) = cos(x)，所以 f(x) = cos(x) 是偶函数。"
         },
         
         {
         question: "将函数 y = f(x) 的图像向上平移 k (k>0) 个单位，得到的函数表达式是什么？",
         options: [
         "y = f(x) - k",
         "y = f(x) + k",
         "y = f(x - k)",
         "y = f(x + k)"
         ],
         answer: "y = f(x) + k",
         explanation: "垂直平移：加正数向上移，加负数（减正数）向下移。"
         },
         {
         question: "将函数 y = f(x) 的图像向右平移 h (h>0) 个单位，得到的函数表达式是什么？",
         options: [
         "y = f(x) - h",
         "y = f(x) + h",
         "y = f(x - h)",
         "y = f(x + h)"
         ],
         answer: "y = f(x - h)",
         explanation: "水平平移：x 减正数向右移，x 加正数向左移。"
         },
         {
         question: "函数 y = a * f(x) (其中 |a| > 1) 的图像相比 y = f(x) 发生了什么变化？",
         options: [
         "沿 y 轴压缩",
         "沿 y 轴伸长",
         "沿 x 轴压缩",
         "沿 x 轴伸长"
         ],
         answer: "沿 y 轴伸长",
         explanation: "y = a * f(x)：当 |a| > 1 时，图像沿 y 轴方向伸长 |a| 倍；当 0 < |a| < 1 时，图像沿 y 轴方向压缩 |a| 倍。"
         },
         {
         question: "函数 y = f(b * x) (其中 |b| > 1) 的图像相比 y = f(x) 发生了什么变化？",
         options: [
         "沿 y 轴压缩",
         "沿 y 轴伸长",
         "沿 x 轴压缩",
         "沿 x 轴伸长"
         ],
         answer: "沿 x 轴压缩",
         explanation: "y = f(b * x)：当 |b| > 1 时，图像沿 x 轴方向压缩到原来的 1/|b| 倍；当 0 < |b| < 1 时，图像沿 x 轴方向伸长到原来的 1/|b| 倍。"
         },
         {
         question: "函数 y = -f(x) 的图像与 y = f(x) 的图像是什么关系？",
         options: [
         "关于原点对称",
         "关于 y 轴对称",
         "关于 x 轴对称",
         "关于直线 y = x 对称"
         ],
         answer: "关于 x 轴对称",
         explanation: "y = -f(x) 是将 y = f(x) 图像上所有点的纵坐标变为相反数，表现为关于 x 轴的反射。"
         },
         {
         question: "函数 y = f(-x) 的图像与 y = f(x) 的图像是什么关系？",
         options: [
         "关于原点对称",
         "关于 y 轴对称",
         "关于 x 轴对称",
         "关于直线 y = x 对称"
         ],
         answer: "关于 y 轴对称",
         explanation: "y = f(-x) 是将 y = f(x) 图像上所有点的横坐标变为相反数，表现为关于 y 轴的反射。"
         },
         
         {
         question: "二次函数 f(x) = ax^2 + bx + c (a≠0) 的图像是什么形状？",
         options: [
         "直线",
         "圆",
         "抛物线",
         "双曲线"
         ],
         answer: "抛物线",
         explanation: "二次函数的图像是一条抛物线。"
         },
         {
         question: "在二次函数 f(x) = ax^2 + bx + c 中，系数 a 决定了抛物线的什么性质？",
         options: [
         "顶点的位置",
         "与 y 轴的交点",
         "开口方向和开口大小",
         "对称轴的位置"
         ],
         answer: "开口方向和开口大小",
         explanation: "如果 a > 0，抛物线开口向上；如果 a < 0，抛物线开口向下。|a| 的大小影响开口的宽窄程度。"
         },
         {
         question: "二次函数 f(x) = ax^2 + bx + c 的对称轴方程是什么？",
         options: [
         "x = -b / a",
         "x = -b / (2a)",
         "x = c / a",
         "x = -c / (2a)"
         ],
         answer: "x = -b / (2a)",
         explanation: "标准形式下二次函数的对称轴方程是 x = -b / (2a)。"
         },
         {
         question: "二次函数的顶点式 f(x) = a(x - h)^2 + k 中，顶点坐标是什么？",
         options: [
         "(-h, k)",
         "(h, k)",
         "(h, -k)",
         "(-h, -k)"
         ],
         answer: "(h, k)",
         explanation: "顶点式直接给出了抛物线的顶点坐标 (h, k)。"
         },
         {
         question: "二次函数的判别式 Delta = b^2 - 4ac 的值大于 0 时，意味着什么？",
         options: [
         "抛物线与 x 轴没有交点",
         "抛物线与 x 轴有一个切点",
         "抛物线与 x 轴有两个不同的交点",
         "抛物线的顶点在 x 轴上"
         ],
         answer: "抛物线与 x 轴有两个不同的交点",
         explanation: "判别式 Delta > 0 意味着对应的二次方程 ax^2 + bx + c = 0 有两个不相等的实数根，这对应于抛物线与 x 轴有两个不同的交点。"
         },
         {
         question: "二次函数的判别式 Delta = b^2 - 4ac 的值等于 0 时，意味着什么？",
         options: [
         "抛物线与 x 轴没有交点",
         "抛物线与 x 轴有一个切点",
         "抛物线与 x 轴有两个不同的交点",
         "抛物线的对称轴是 y 轴"
         ],
         answer: "抛物线与 x 轴有一个切点",
         explanation: "判别式 Delta = 0 意味着对应的二次方程 ax^2 + bx + c = 0 有一个重根（或两个相等的实数根），这对应于抛物线与 x 轴相切于一点（顶点在 x 轴上）。"
         },
         {
         question: "二次函数的判别式 Delta = b^2 - 4ac 的值小于 0 时，意味着什么？",
         options: [
         "抛物线与 x 轴没有交点",
         "抛物线与 x 轴有一个切点",
         "抛物线与 x 轴有两个不同的交点",
         "抛物线开口向下"
         ],
         answer: "抛物线与 x 轴没有交点",
         explanation: "判别式 Delta < 0 意味着对应的二次方程 ax^2 + bx + c = 0 没有实数根，这对应于抛物线整个位于 x 轴的上方（如果 a>0）或下方（如果 a<0），与 x 轴没有交点。"
         },
         
         {
         question: "有理函数 (Rational Function) 的定义是什么？",
         options: [
         "两个多项式的和",
         "两个多项式的积",
         "两个多项式的商 (分母不为零)",
         "多项式的平方根"
         ],
         answer: "两个多项式的商 (分母不为零)",
         explanation: "有理函数形如 f(x) = P(x) / Q(x)，其中 P(x) 和 Q(x) 都是多项式，并且 Q(x) 不能是零多项式。"
         },
         {
         question: "如何找到有理函数 f(x) = P(x) / Q(x) 的垂直渐近线？",
         options: [
         "令 P(x) = 0 求解",
         "令 Q(x) = 0 求解，并确保 P(x) 在该处不为零",
         "比较 P(x) 和 Q(x) 的次数",
         "计算函数在 x=0 处的值"
         ],
         answer: "令 Q(x) = 0 求解，并确保 P(x) 在该处不为零",
         explanation: "垂直渐近线出现在使分母 Q(x) 为零，但分子 P(x) 不为零的 x 值处。这些 x 值是函数定义域中不存在的点，函数值在这些点附近趋向于无穷大。"
         },
         {
         question: "对于有理函数 f(x) = P(x) / Q(x)，如果分子 P(x) 的次数小于分母 Q(x) 的次数，水平渐近线是什么？",
         options: [
         "y = 0 (x 轴)",
         "没有水平渐近线",
         "y = (P的最高次项系数) / (Q的最高次项系数)",
         "y = 1"
         ],
         answer: "y = 0 (x 轴)",
         explanation: "当分子的次数低于分母的次数时，随着 |x| 趋向无穷大，函数值趋向于 0，因此水平渐近线是 y = 0。"
         },
         {
         question: "对于有理函数 f(x) = P(x) / Q(x)，如果分子 P(x) 的次数等于分母 Q(x) 的次数，水平渐近线是什么？",
         options: [
         "y = 0 (x 轴)",
         "没有水平渐近线",
         "y = (P的最高次项系数) / (Q的最高次项系数)",
         "y = 1"
         ],
         answer: "y = (P的最高次项系数) / (Q的最高次项系数)",
         explanation: "当分子和分母次数相等时，随着 |x| 趋向无穷大，函数值趋向于它们最高次项系数的比值，因此水平渐近线是 y = 这个比值。"
         },
         {
         question: "(HL) 对于有理函数 f(x) = P(x) / Q(x)，存在斜渐近线 (Slant Asymptote) 的条件是什么？",
         options: [
         "分子次数小于分母次数",
         "分子次数等于分母次数",
         "分子次数恰好比分母次数大 1",
         "分子次数比分母次数大 2 或更多"
         ],
         answer: "分子次数恰好比分母次数大 1",
         explanation: "当分子多项式的次数正好比分母多项式的次数大 1 时，该有理函数存在一条斜渐近线。"
         },
         {
         question: "(HL) 如何求有理函数 f(x) = P(x) / Q(x) 的斜渐近线方程？",
         options: [
         "计算 P(x) / Q(x) 的导数",
         "进行多项式长除法，斜渐近线方程是 y = 商",
         "令 P(x) = 0 求解",
         "令 Q(x) = 0 求解"
         ],
         answer: "进行多项式长除法，斜渐近线方程是 y = 商",
         explanation: "通过对 P(x) 除以 Q(x) 进行多项式长除法，得到 P(x)/Q(x) = (商) + (余数)/Q(x)。当 |x| 趋向无穷大时，(余数)/Q(x) 趋向于 0，因此函数的图像趋近于直线 y = 商（一个形如 mx+b 的线性表达式）。"
         },
         {
         question: "如何找到有理函数 f(x) = P(x) / Q(x) 的 x 轴截距？",
         options: [
         "令 x = 0",
         "令 Q(x) = 0 求解",
         "令 P(x) = 0 求解 (并确保 Q(x) ≠ 0)",
         "找垂直渐近线"
         ],
         answer: "令 P(x) = 0 求解 (并确保 Q(x) ≠ 0)",
         explanation: "x 轴截距是函数图像与 x 轴相交的点，此时 y=f(x)=0。这要求分子 P(x) = 0，同时分母 Q(x) 不能为零。"
         },
         
         {
         question: "多项式函数 f(x) = a_n*x^n + ... + a_1*x + a_0 的次数 (degree) 是什么？",
         options: [
         "常数项 a_0",
         "最高次项的系数 a_n",
         "自变量 x 的最高次幂 n",
         "多项式中项的数量"
         ],
         answer: "自变量 x 的最高次幂 n",
         explanation: "多项式的次数是由其非零项中自变量 x 的最高指数决定的。"
         },
         {
         question: "余数定理 (Remainder Theorem) 说明了什么？",
         options: [
         "多项式 P(x) 除以 (x - c) 的余数是 P(c)",
         "多项式 P(x) 除以 (x - c) 的余数是 0",
         "如果 P(c) = 0，则 (x - c) 是 P(x) 的因式",
         "多项式的根都是整数"
         ],
         answer: "多项式 P(x) 除以 (x - c) 的余数是 P(c)",
         explanation: "余数定理指出，将多项式 P(x) 除以线性因子 (x - c) 所得到的余数等于将 c 代入多项式计算出的值 P(c)。"
         },
         {
         question: "因式定理 (Factor Theorem) 说明了什么？",
         options: [
         "多项式 P(x) 除以 (x - c) 的余数是 P(c)",
         "(x - c) 是多项式 P(x) 的一个因式当且仅当 P(c) = 0",
         "所有多项式都可以分解为线性因子的乘积",
         "多项式的次数等于其根的数量"
         ],
         answer: "(x - c) 是多项式 P(x) 的一个因式当且仅当 P(c) = 0",
         explanation: "因式定理是余数定理的一个特例，它说明如果 P(c) = 0（即 c 是多项式的一个根），那么 (x - c) 就是 P(x) 的一个因式，反之亦然。"
         },
         {
         question: "如果一个多项式函数图像在 x = c 处穿过 x 轴，那么 c 作为根的重数 (multiplicity) 可能是什么？",
         options: [
         "偶数",
         "奇数",
         "零",
         "负数"
         ],
         answer: "奇数",
         explanation: "当根的重数是奇数（1, 3, 5, ...）时，函数图像在根的位置会穿过 x 轴。"
         },
         {
         question: "如果一个多项式函数图像在 x = c 处与 x 轴相切但不穿过，那么 c 作为根的重数 (multiplicity) 可能是什么？",
         options: [
         "偶数",
         "奇数",
         "1",
         "分数"
         ],
         answer: "偶数",
         explanation: "当根的重数是偶数（2, 4, 6, ...）时，函数图像在根的位置会接触（相切于）x 轴，但不会穿过它，函数值在根的两侧符号相同。"
         },
         {
         question: "一个 n 次多项式在复数范围内最多有多少个根（计入重数）？",
         options: [
         "n-1 个",
         "n 个",
         "n+1 个",
         "2n 个"
         ],
         answer: "n 个",
         explanation: "根据代数基本定理 (Fundamental Theorem of Algebra)，任何一个次数为 n (n≥1) 的复系数多项式方程在复数范围内恰好有 n 个根（包括重根）。对于实系数多项式也适用。"
         },
         {
         question: "(HL) 如果 a + bi (b≠0) 是一个实系数多项式方程的一个复数根，那么根据复共轭根定理，另一个根必定是什么？",
         options: [
         "a - bi",
         "-a + bi",
         "-a - bi",
         "1 / (a + bi)"
         ],
         answer: "a - bi",
         explanation: "复共轭根定理指出，如果一个实系数多项式有一个虚根 z，那么它的共轭复数 z_conjugate 也一定是该多项式的一个根。"
         },
         {
         question: "(HL) 对于二次方程 ax^2 + bx + c = 0 的两个根 α 和 β，根据韦达定理 (Vieta's formulas)，α + β 等于什么？",
         options: [
         "c / a",
         "-c / a",
         "b / a",
         "-b / a"
         ],
         answer: "-b / a",
         explanation: "韦达定理给出了多项式方程的根与系数之间的关系。对于二次方程，两根之和等于 -b/a。"
         },
         {
         question: "(HL) 对于二次方程 ax^2 + bx + c = 0 的两个根 α 和 β，根据韦达定理 (Vieta's formulas)，α * β 等于什么？",
         options: [
         "c / a",
         "-c / a",
         "b / a",
         "-b / a"
         ],
         answer: "c / a",
         explanation: "韦达定理指出，对于二次方程，两根之积等于 c/a。"
         },
         {
         question: "考虑多项式函数 f(x) = 3x^4 - 2x^2 + 5。当 x 趋向正无穷大时，f(x) 的行为主要由哪一项决定？",
         options: [
         "常数项 5",
         "-2x^2 项",
         "3x^4 项",
         "所有项共同决定"
         ],
         answer: "3x^4 项",
         explanation: "多项式的端点行为（当 |x| 变得非常大时）由其最高次项决定。因为 3x^4 在 x 很大时增长最快。"
         },
         {
         question: "(HL) 绝对值函数 |x| 的定义是什么？",
         options: [
         "|x| = x",
         "|x| = -x",
         "|x| = x 如果 x ≥ 0, |x| = -x 如果 x < 0",
         "|x| = sqrt(x^2)"
         ],
         answer: "|x| = x 如果 x ≥ 0, |x| = -x 如果 x < 0",
         explanation: "绝对值表示一个数到原点的距离，所以非负数的绝对值是它本身，负数的绝对值是它的相反数。选项 D (|x| = sqrt(x^2)) 在实数范围内也是等价的定义。"
         },
         {
         question: "(HL) 函数 y = |x| 的图像是什么形状？",
         options: [
         "抛物线",
         "直线",
         "在原点处呈 V 形的折线",
         "半圆形"
         ],
         answer: "在原点处呈 V 形的折线",
         explanation: "y = |x| 的图像由两段射线组成：当 x≥0 时是 y=x，当 x<0 时是 y=-x，它们在原点 (0,0) 相交形成一个 V 形。"
         },
         {
         question: "(HL) 如何解绝对值方程 |f(x)| = c (其中 c ≥ 0)？",
         options: [
         "f(x) = c",
         "f(x) = -c",
         "f(x) = c 或 f(x) = -c",
         "f(x) = ±c^2"
         ],
         answer: "f(x) = c 或 f(x) = -c",
         explanation: "如果一个表达式的绝对值等于一个非负常数 c，那么这个表达式本身要么等于 c，要么等于 -c。"
         },
         {
         question: "(HL) 如何解绝对值不等式 |f(x)| < c (其中 c > 0)？",
         options: [
         "f(x) < c",
         "f(x) > -c",
         "-c < f(x) < c",
         "f(x) < -c 或 f(x) > c"
         ],
         answer: "-c < f(x) < c",
         explanation: "如果一个表达式的绝对值小于一个正常数 c，那么这个表达式本身必须介于 -c 和 c 之间。"
         },
         {
         question: "(HL) 如何解绝对值不等式 |f(x)| > c (其中 c > 0)？",
         options: [
         "f(x) > c",
         "f(x) < -c",
         "-c < f(x) < c",
         "f(x) < -c 或 f(x) > c"
         ],
         answer: "f(x) < -c 或 f(x) > c",
         explanation: "如果一个表达式的绝对值大于一个正常数 c，那么这个表达式本身要么大于 c，要么小于 -c。"
         },
         {
         question: "(HL) 从函数 y = f(x) 的图像变换到 y = |f(x)| 的图像，需要做什么操作？",
         options: [
         "保留 x 轴上方的部分，将 x 轴下方的部分关于 x 轴翻折上去",
         "保留 y 轴右侧的部分，然后关于 y 轴对称得到左侧部分",
         "将整个图像关于 x 轴对称",
         "将整个图像关于 y 轴对称"
         ],
         answer: "保留 x 轴上方的部分，将 x 轴下方的部分关于 x 轴翻折上去",
         explanation: "y = |f(x)| 的效果是保持 f(x) 非负的部分不变，将 f(x) 为负的部分取其相反数（变为正值），这在图像上表现为将 x 轴下方的图像翻折到 x 轴上方。"
         },
         {
         question: "(HL) 从函数 y = f(x) 的图像变换到 y = f(|x|) 的图像，需要做什么操作？",
         options: [
         "保留 x 轴上方的部分，将 x 轴下方的部分关于 x 轴翻折上去",
         "保留 y 轴右侧 (x≥0) 的部分，舍弃左侧部分，然后将右侧部分关于 y 轴对称得到新的左侧部分",
         "将整个图像向右平移",
         "将整个图像向上平移"
         ],
         answer: "保留 y 轴右侧 (x≥0) 的部分，舍弃左侧部分，然后将右侧部分关于 y 轴对称得到新的左侧部分",
         explanation: "y = f(|x|) 的效果是：当 x≥0 时，f(|x|) = f(x)；当 x<0 时，f(|x|) = f(-x)。这在图像上表现为保留 y 轴右侧的图像，并用这部分图像关于 y 轴的对称图像替换掉 y 轴左侧的原图像，使得最终图像关于 y 轴对称。"
         },
         {
         question: "(HL) 三角不等式 (Triangle Inequality) 指的是下列哪个关系？",
         options: [
         "|a + b| = |a| + |b|",
         "|a + b| ≥ |a| + |b|",
         "|a + b| ≤ |a| + |b|",
         "|a - b| = |a| - |b|"
         ],
         answer: "|a + b| ≤ |a| + |b|",
         explanation: "三角不等式表明，两个数（或向量）之和的绝对值（或模长）小于或等于这两个数（或向量）绝对值（或模长）的和。"
         },
         
         {
         question: "(HL) 如果点 (a, b) 在函数 y = f(x) 的图像上，那么哪个点一定在其反函数 y = f^(-1)(x) 的图像上？",
         options: [
         "(a, b)",
         "(-a, b)",
         "(a, -b)",
         "(b, a)"
         ],
         answer: "(b, a)",
         explanation: "反函数的定义意味着如果 f 将 a 映射到 b，那么 f^(-1) 将 b 映射回 a。因此，原函数图像上的点 (a, b) 对应反函数图像上的点 (b, a)。"
         },
         {
         question: "(HL) 自反函数 (Self-inverse function) 的定义是什么？",
         options: [
         "f(x) = -f(x)",
         "f(x) = f(-x)",
         "f(f(x)) = x",
         "f(x) = 1 / f(x)"
         ],
         answer: "f(f(x)) = x",
         explanation: "一个函数是自反的，意味着应用该函数两次会回到原始输入值，即 f(x) 的反函数是其自身 (f = f^(-1))，或者说复合函数 (f o f)(x) = x。"
         },
         {
         question: "(HL) 下列哪个函数是自反函数 (Self-inverse function) 的例子？",
         options: [
         "f(x) = x^2 (x≥0)",
         "f(x) = e^x",
         "f(x) = 1/x (x≠0)",
         "f(x) = sin(x)"
         ],
         answer: "f(x) = 1/x (x≠0)",
         explanation: "对于 f(x) = 1/x，f(f(x)) = f(1/x) = 1 / (1/x) = x。因此 f(x) = 1/x 是一个自反函数。f(x) = x 也是一个简单的自反函数。f(x) = c - x 也是。"
         }
         ];
           const quizContainer = document.getElementById('quiz-container');
           const gameArea = document.getElementById('game-area');
           const resultsArea = document.getElementById('results-area');
           const questionCounter = document.getElementById('question-counter');
           const scoreDisplay = document.getElementById('score-display');
           const progressBar = document.getElementById('progress-bar');
           const questionText = document.getElementById('question-text');
           const optionsContainer = document.getElementById('options-container');
           const feedbackArea = document.getElementById('feedback-area');
           const feedbackText = document.getElementById('feedback-text');
           const explanationText = document.getElementById('explanation-text');
           const nextBtn = document.getElementById('next-btn');
           const finalScore = document.getElementById('final-score');
           const resultMessage = document.getElementById('result-message');
           const restartBtn = document.getElementById('restart-btn');
           const confettiCanvas = document.getElementById('confetti-canvas');
           let myConfettiInstance = null;
           if (confettiCanvas && typeof confetti !== 'undefined') {
               myConfettiInstance = confetti.create(confettiCanvas, {
                   resize: true,
                   useWorker: true
               });
           }
           let currentQuestionIndex = 0;
           let score = 0;
           let questionsAnsweredInSession = 0;
           let shuffledQuestions = [];
           function shuffleArray(array) {
               for (let i = array.length - 1; i > 0; i--) {
                   const j = Math.floor(Math.random() * (i + 1));
                   [array[i], array[j]] = [array[j], array[i]];
               }
               return array;
           }
           function updateScoreDisplay() {
               const percentage = questionsAnsweredInSession === 0 ? 0 : Math.round((score / questionsAnsweredInSession) * 100);
               scoreDisplay.textContent = `得分: ${score} / ${questionsAnsweredInSession} (${percentage}%)`;
           }
           function updateProgressBar() {
               const totalQuestionsToDisplay = shuffledQuestions.length;
               const progressPercentage = totalQuestionsToDisplay === 0 ? 0 : Math.round(((currentQuestionIndex) / totalQuestionsToDisplay) * 100);
               progressBar.style.width = `${progressPercentage}%`;
               progressBar.textContent = `${progressPercentage}%`;
           }
           function updateProgressBarAfterAnswer() {
               const totalQuestionsToDisplay = shuffledQuestions.length;
               const progressPercentage = totalQuestionsToDisplay === 0 ? 0 : Math.round(((currentQuestionIndex + 1) / totalQuestionsToDisplay) * 100);
               progressBar.style.width = `${progressPercentage}%`;
               progressBar.textContent = `${progressPercentage}%`;
           }
           function startGame() {
               currentQuestionIndex = 0;
               score = 0;
               questionsAnsweredInSession = 0;
               shuffledQuestions = shuffleArray([...questions]);
               updateScoreDisplay();
               progressBar.style.width = '0%';
               progressBar.textContent = '0%';
               resultsArea.classList.add('hidden');
               resultsArea.classList.remove('results-enter', 'results-enter-active'); 
               gameArea.classList.remove('hidden'); 
               nextBtn.classList.add('hidden'); 
               feedbackArea.classList.add('hidden'); 
               explanationText.innerHTML = ''; 
               showQuestion();
           }
           function showQuestion() {
               updateProgressBar();
               optionsContainer.innerHTML = '';
               feedbackArea.classList.add('hidden');
               feedbackText.textContent = '';
               explanationText.innerHTML = '';
               feedbackText.className = 'text-lg font-semibold mb-2';
               const currentQuestion = shuffledQuestions[currentQuestionIndex];
               questionText.innerHTML = currentQuestion.question;
               questionCounter.textContent = `问题 ${currentQuestionIndex + 1} / ${shuffledQuestions.length}`;
               const shuffledOptions = shuffleArray([...currentQuestion.options]);
               shuffledOptions.forEach(option => {
                   const button = document.createElement('button');
                   button.innerHTML = option;
                   button.className = 'option-btn bg-white hover:bg-gray-100 text-gray-700 font-medium py-3 px-4 border border-gray-300 rounded-lg shadow-sm transition duration-200 ease-in-out w-full text-left';
                   button.addEventListener('click', selectAnswer);
                   optionsContainer.appendChild(button);
               });
               nextBtn.classList.add('hidden');
           }
           function triggerConfetti() {
               if (myConfettiInstance) {
                   myConfettiInstance({
                       particleCount: 120,
                       spread: 80,
                       origin: { y: 0.6 },
                       colors: ['#a855f7', '#ec4899', '#f59e0b', '#22c55e', '#3b82f6']
                   });
               }
           }
           function selectAnswer(e) {
               const selectedButton = e.target.closest('.option-btn');
               if (!selectedButton) return;
               const currentQuestion = shuffledQuestions[currentQuestionIndex];
               const correctAnswer = currentQuestion.answer;
               const explanation = currentQuestion.explanation;
               questionsAnsweredInSession++;
               Array.from(optionsContainer.children).forEach(button => {
                   button.disabled = true;
                   if (button.innerHTML === correctAnswer) {
                       button.classList.add('correct-answer');
                   }
               });
               if (selectedButton.innerHTML === correctAnswer) {
                   score++;
                   feedbackText.textContent = '✅ 回答正确!';
                   feedbackText.className = 'text-lg font-semibold mb-2 text-green-600';
                   selectedButton.classList.add('correct-answer');
                   triggerConfetti();
               } else {
                   feedbackText.textContent = `❌ 回答错误!`;
                   feedbackText.className = 'text-lg font-semibold mb-2 text-red-600';
                   selectedButton.classList.add('wrong-answer');
               }
         
               explanationText.innerHTML = `<strong>解析:</strong> ${explanation}`;
               feedbackArea.classList.remove('hidden');
         
               updateScoreDisplay();
               updateProgressBarAfterAnswer();
               nextBtn.classList.remove('hidden');
           }
           function showNextQuestion() {
               currentQuestionIndex++;
               if (currentQuestionIndex < shuffledQuestions.length) {
                   showQuestion();
               } else {
                   endGame();
               }
           }
           function endGame() {
               gameArea.classList.add('hidden');
               resultsArea.classList.remove('hidden');
               requestAnimationFrame(() => {
                    resultsArea.classList.add('results-enter');
                    requestAnimationFrame(() => {
                        resultsArea.classList.add('results-enter-active');
                   });
               });
         
               const finalPercentage = shuffledQuestions.length === 0 ? 0 : Math.round((score / shuffledQuestions.length) * 100);
               finalScore.textContent = `你的最终得分是: ${score} / ${shuffledQuestions.length} (${finalPercentage}%)`;
               let message = '';
               if (finalPercentage === 100) {
                   message = '💯 完美！你简直是 IB Math AA HL 大师！知识点掌握得炉火纯青！';
                   if (myConfettiInstance) {
                        myConfettiInstance({ particleCount: 200, spread: 160, origin: { y: 0.5 }}); 
                        myConfettiInstance({ particleCount: 200, spread: 160, origin: { y: 0.7 }}); 
                   }
               } else if (finalPercentage >= 90) {
                   message = '🌟 太出色了！对数学的理解非常深刻，绝对的学霸！';
                   if (myConfettiInstance) { myConfettiInstance({particleCount: 150, spread: 100}); }
               } else if (finalPercentage >= 80) {
                   message = '🏆 非常棒！知识掌握得很扎实，向着7分前进！';
               } else if (finalPercentage >= 70) {
                   message = '🎉 很厉害！展现了良好的理解，继续努力，7分在望！';
               } else if (finalPercentage >= 60) {
                   message = '👍 相当不错！大部分知识点都理解了，继续加油！';
               } else if (finalPercentage >= 50) {
                   message = '😊 不错！掌握了核心内容，可以更有自信！';
               } else {
                   message = '💪 不要灰心！从错误中学习，梳理知识点，下次一定能进步！';
               }
               resultMessage.textContent = message;
           }
           nextBtn.addEventListener('click', showNextQuestion);
           restartBtn.addEventListener('click', startGame);
           startGame();
         
      </script>
   </body>
</html>